class Store
types
	public NotEmptyString = seq1 of char;
	public ClientsToCredits = map nat to real;
values
	public CREDIT_NOTE_MULTIPLIER: real = 1.2;
instance variables
	location: NotEmptyString;
	productsAvailable: set of Product := {};
	productsSold: set of Product := {};
	giftCardsSold: set of GiftCard := {};
	clientsCreditNotes: ClientsToCredits := { |-> }; -- map ids of clients to its credit notes
	cashiers: set of StoreCashier := {};
	
operations
	public Store: NotEmptyString ==> Store
	Store(storeLocation) ==
		(location := storeLocation;
		return self;)
		pre len storeLocation > 0
		post 
			location = storeLocation and 
			productsAvailable = {} and 
			productsSold = {} and 
			clientsCreditNotes = { |-> } and
			cashiers = {};
			
	public addCashier: StoreCashier ==> ()
		addCashier(cashier) ==
		cashiers := cashiers union {cashier}
		pre true
		post cashiers = cashiers~ union {cashier};
		
	public buyProductInCash: Product ==> ()
		buyProductInCash(p) ==
		productsAvailable := productsAvailable union {p}
		pre true
		post productsAvailable = productsAvailable~ union {p};
	
	public buyProductInCreditNotes: Product * nat1 ==> ()
	buyProductInCreditNotes(p, clientId) ==
		(
		buyProductInCash(p);
		addCreditNote(clientId, p);
		)
		pre true
		post productsAvailable = productsAvailable~ union {p} and
		checkCreditNotes(clientId, p, clientsCreditNotes, clientsCreditNotes~);
	
	public sellGiftCard: (nat1) ==> GiftCard
	sellGiftCard(value) ==
		(
		dcl newGiftCard:GiftCard := new GiftCard(value);
		giftCardsSold := giftCardsSold union {newGiftCard};
		return newGiftCard;
		)
		pre true
		post card giftCardsSold = card giftCardsSold~ + 1;
	
	public sellProduct: Product ==> ()
	sellProduct(p) ==
		(
		productsAvailable := productsAvailable \ {p};
		productsSold := productsSold union {p};
		)
		pre hasProduct(p)
		post productsAvailable = productsAvailable~ \ {p} and productsSold = productsSold~ union {p};
	
	public sellProductInCreditNotes: Product * nat ==> ()
	sellProductInCreditNotes(p, clientId) ==
		(
		sellProduct(p);
		spendCreditNote(clientId, p.getSellPrice());
		)
		pre hasProduct(p) and getCreditNotesOfClient(clientId) >= p.getSellPrice()
		post productsAvailable = productsAvailable~ \ {p} and
					productsSold = productsSold~ union {p}; -- should also check that creditNotes of client have decreased
	
	
	public pure getCreditNotesOfClient: nat ==> real
	getCreditNotesOfClient(clientId) ==
		return clientsCreditNotes(clientId)
		pre clientId in set dom clientsCreditNotes
		post RESULT = clientsCreditNotes(clientId);

	public pure getProductsAvailable: () ==> set of Product
	getProductsAvailable() ==
		return productsAvailable
		pre true
		post RESULT = productsAvailable;
		
	public pure getCashiers: () ==> set of StoreCashier
	getCashiers() ==
		return cashiers
		pre true
		post RESULT = cashiers;
	
	public addCreditNote: real * Product ==> ()
	addCreditNote(clientId, p) ==
			(
			(if clientId not in set dom clientsCreditNotes
				then clientsCreditNotes := clientsCreditNotes ++ {clientId |-> 0}
			);
			clientsCreditNotes := clientsCreditNotes ++ 
				{clientId |-> clientsCreditNotes(clientId) + p.getBuyPrice() * CREDIT_NOTE_MULTIPLIER}
			)
			pre true
			post checkCreditNotes(clientId, p, clientsCreditNotes, clientsCreditNotes~);
	
	/**
	Spend a credit note
	The value of the credit note to send should be less or equal than the creditNotes amount
	*/		
	public spendCreditNote: nat * real ==> ()
	spendCreditNote(clientId, value) ==
			clientsCreditNotes := clientsCreditNotes ++ {clientId |-> clientsCreditNotes(clientId) - value}
			pre clientId in set dom clientsCreditNotes and value <= clientsCreditNotes(clientId)
			post clientsCreditNotes = clientsCreditNotes~ ++ {clientId |-> clientsCreditNotes~(clientId) - value};

	public pure hasProduct: Product ==> bool
	hasProduct(p) ==
		return p in set productsAvailable
		post RESULT = p in set productsAvailable;

functions
	public checkCreditNotes: nat * Product * ClientsToCredits * ClientsToCredits -> bool
	checkCreditNotes(clientId, p, newCreditNotes, oldCreditNotes) ==
	(if clientId not in set dom oldCreditNotes then
			newCreditNotes(clientId) = p.getBuyPrice() * CREDIT_NOTE_MULTIPLIER
	else	
			newCreditNotes = oldCreditNotes ++ {clientId |-> oldCreditNotes(clientId) + p.getBuyPrice() * CREDIT_NOTE_MULTIPLIER}
	)
traces
-- TODO Define Combinatorial Test Traces here
end Store