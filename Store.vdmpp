class Store
types
	public NotEmptyString = seq1 of char;
	
values
	public CREDIT_NOTE_MULTIPLIER: real = 1.2;
instance variables
	location: NotEmptyString;
	productsAvailable: set of Product := {};
	productsSold: set of Product := {};
	clientsCreditNotes: map nat to nat := { |-> }; -- map ids of clients to its credit notes
	cashiers: set of StoreCashier := {};
	
operations
	public Store(storeLocation: NotEmptyString) s: Store ==
		(location := storeLocation;
		return self;)
		pre len storeLocation > 0
		post 
			location = storeLocation and 
			productsAvailable = {} and 
			productsSold = {} and 
			clientsCreditNotes = { |-> } and
			cashiers = {};
	
	public buyProductInCash(p: Product) == 
	is not yet specified
	pre true
	post productsAvailable = productsAvailable~ union {p};
	
	public buyProductInCreditNotes(p: Product, clientId: nat) == 
	is not yet specified
	pre true
	post productsAvailable = productsAvailable~ union {p} and
	checkCreditNotes(clientId, p, clientsCreditNotes, clientsCreditNotes~);
	
	public sellProduct(p: Product) ==
	is not yet specified
	pre p in set productsAvailable
	post productsAvailable = productsAvailable~ \ {p} and productsSold = productsSold~ union {p};
	
	public getCreditNotesOfClient(clientId: nat) res: nat == 
		is not yet specified
		pre clientId in set dom clientsCreditNotes
		post res = clientsCreditNotes(clientId);

	public getProductsAvailable() p: set of Product ==
		return productsAvailable
		pre true
		post p = productsAvailable;
		
	public getCashiers() c: set of StoreCashier ==
		return cashiers
		pre true
		post c = cashiers;
	
	public addCreditNote(clientId: nat, p: Product) ==
			(
			(if clientId not in set dom clientsCreditNotes
				then clientsCreditNotes := clientsCreditNotes ++ {clientId |-> 0}
			);
			clientsCreditNotes := clientsCreditNotes ++ 
				{clientId |-> clientsCreditNotes(clientId) + p.getBuyPrice() * CREDIT_NOTE_MULTIPLIER}
			)
			pre true
			post checkCreditNotes(clientId, p, clientsCreditNotes, clientsCreditNotes~);
	
	/**
	Spend a credit note
	The value of the credit note to send should be less or equal than the creditNotes amount
	*/		
	public spendCreditNote(clientId: nat, value: nat) == 
			clientsCreditNotes := clientsCreditNotes ++ {clientId |-> clientsCreditNotes(clientId) - value}
			pre clientId in set dom clientsCreditNotes and value <= clientsCreditNotes(clientId)
			post clientsCreditNotes = clientsCreditNotes~ ++ {clientId |-> clientsCreditNotes~(clientId) - value}

functions
	public checkCreditNotes(
			clientId: nat,
			p: Product,
			newCreditNotes: map nat to nat,
			oldCreditNotes: map nat to nat
	) res:bool ==
		newCreditNotes = oldCreditNotes ++
				{clientId |-> oldCreditNotes(clientId) + p.getBuyPrice() * CREDIT_NOTE_MULTIPLIER};
traces
-- TODO Define Combinatorial Test Traces here
end Store