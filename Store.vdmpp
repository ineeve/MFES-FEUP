class Store
types
	public NotEmptyString = seq1 of char;
	
values
	public CREDIT_NOTE_MULTIPLIER: real = 1.2;
instance variables
	location: NotEmptyString;
	productsAvailable: set of Product := {};
	productsSold: set of Product := {};
	giftCardsSold: set of GiftCard := {};
	clientsCreditNotes: map nat to nat := { |-> }; -- map ids of clients to its credit notes
	cashiers: set of StoreCashier := {};
	
operations
	public Store(storeLocation: NotEmptyString) s: Store ==
		(location := storeLocation;
		return self;)
		pre len storeLocation > 0
		post 
			location = storeLocation and 
			productsAvailable = {} and 
			productsSold = {} and 
			clientsCreditNotes = { |-> } and
			cashiers = {};
	
	public buyProductInCash(p: Product) == 
		is not yet specified
		pre true
		post productsAvailable = productsAvailable~ union {p};
	
	public buyProductInCreditNotes(p: Product, clientId: nat) == 
		is not yet specified
		pre true
		post productsAvailable = productsAvailable~ union {p} and
		checkCreditNotes(clientId, p, clientsCreditNotes, clientsCreditNotes~);
	
	public sellGiftCard: (nat1) ==> GiftCard
	sellGiftCard(value) ==
		(
		dcl newGiftCard:GiftCard := new GiftCard(value);
		giftCardsSold := giftCardsSold union {newGiftCard};
		return newGiftCard;
		)
		pre true
		post card giftCardsSold = card giftCardsSold~ + 1;
	
	public sellProduct(p: Product) ==
		(
		productsAvailable := productsAvailable \ {p};
		productsSold := productsSold union {p};
		)
		pre hasProduct(p)
		post productsAvailable = productsAvailable~ \ {p} and productsSold = productsSold~ union {p};
	
	public sellProductInCreditNotes(p: Product, clientId: nat) ==
		(
		sellProduct(p);
		spendCreditNote(clientId, p.getSellPrice());
		)
		pre hasProduct(p) and getCreditNotesOfClient(clientId) >= p.getSellPrice()
		post productsAvailable = productsAvailable~ \ {p} and
					productsSold = productsSold~ union {p}; -- should also check that creditNotes of client have decreased
	
	
	public pure getCreditNotesOfClient: nat ==> nat
	getCreditNotesOfClient(clientId) ==
		return clientsCreditNotes(clientId)
		pre clientId in set dom clientsCreditNotes
		post res = clientsCreditNotes(clientId);

	public getProductsAvailable: () ==> set of Product
	getProductsAvailable() ==
		return productsAvailable
		pre true
		post RESULT = productsAvailable;
		
	public getCashiers: () ==> set of StoreCashier
	getCashiers() ==
		return cashiers
		pre true
		post RESULT = cashiers;
	
	public addCreditNote: nat * Product ==> ()
	addCreditNote(clientId, p) ==
			(
			(if clientId not in set dom clientsCreditNotes
				then clientsCreditNotes := clientsCreditNotes ++ {clientId |-> 0}
			);
			clientsCreditNotes := clientsCreditNotes ++ 
				{clientId |-> clientsCreditNotes(clientId) + p.getBuyPrice() * CREDIT_NOTE_MULTIPLIER}
			)
			pre true
			post checkCreditNotes(clientId, p, clientsCreditNotes, clientsCreditNotes~);
	
	/**
	Spend a credit note
	The value of the credit note to send should be less or equal than the creditNotes amount
	*/		
	public spendCreditNote: nat * nat ==> ()
	spendCreditNote(clientId, value) ==
			clientsCreditNotes := clientsCreditNotes ++ {clientId |-> clientsCreditNotes(clientId) - value}
			pre clientId in set dom clientsCreditNotes and value <= clientsCreditNotes(clientId)
			post clientsCreditNotes = clientsCreditNotes~ ++ {clientId |-> clientsCreditNotes~(clientId) - value};

	public pure hasProduct: Product ==> bool
	hasProduct(p) ==
		return p in set productsAvailable
		post RESULT = p in set productsAvailable;

functions
	public checkCreditNotes: nat * Product * map nat to nat * map nat to nat -> bool
	checkCreditNotes(clientId, p, newCreditNotes, oldCreditNotes) ==
		newCreditNotes = oldCreditNotes ++
				{clientId |-> oldCreditNotes(clientId) + p.getBuyPrice() * CREDIT_NOTE_MULTIPLIER};
traces
-- TODO Define Combinatorial Test Traces here
end Store