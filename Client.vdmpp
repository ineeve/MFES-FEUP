class Client
types
	public NotEmptyString = seq1 of char;
values
instance variables
	static idCounter: nat := 0;
	id: nat1;
	name: NotEmptyString;
	boughtProducts: set of Product := {};
	soldProducts: set of Product := {};
	boughtGiftCards: set of GiftCard := {};
operations
	public Client(nameSeq: NotEmptyString) c: Client ==
			(name:=nameSeq;idCounter := idCounter + 1;id := idCounter; return self)
			 pre len nameSeq > 0
			 post len name > 0 and 
			 id = idCounter~ + 1 and
			 boughtProducts = {} and
			 soldProducts = {} and 
			 boughtGiftCards = {};
	
	public pure getId() res:nat1 == 
		return id
		ext rd id
		pre true
		post res=id;

	/*
	Post:
	- Has one more product of the bought kind in purchase transactions than previously.
	*/
	public buyProduct(product: Product) ==
		(
		boughtProducts := boughtProducts union {product};
		)
		pre true
		post
			card boughtProducts = card boughtProducts~ + 1
			and product in set boughtProducts;
		
	/*
	Pre:
	Post:
	- Has one more product of the sold kind in sales transactions than previously.
	*/
	public sellProduct(product: Product) ==
		soldProducts := soldProducts union {product}
		pre true
		post
			card soldProducts = card soldProducts~ + 1
			and product in set soldProducts;
			
	public buyGiftCard(giftCard: GiftCard) ==
		boughtGiftCards := boughtGiftCards union {giftCard}
		pre true
		post card boughtGiftCards = card boughtGiftCards~ + 1 and
		giftCard in set boughtGiftCards;
		
pure valuesFromGiftCards(g: set of GiftCard) res: seq of nat ==
	 (dcl result: seq of nat := [];
		for all giftCard in set g do 
		(result := result ^ [giftCard.getValue()];);
		return result;)
		pre true
		post card g = len res;
		
functions
	
		

traces
-- TODO Define Combinatorial Test Traces here
end Client