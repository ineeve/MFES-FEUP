class Client
types
	public NotEmptyString = seq1 of char;
values
instance variables
	static idCounter: nat := 0;
	id: nat1;
	name: NotEmptyString;
	boughtProducts: set of Product := {};
	soldProducts: set of Product := {};
	boughtGiftCards: set of GiftCard := {};
operations
	public Client: NotEmptyString ==> Client
	Client(nameSeq) ==
			(name:=nameSeq;idCounter := idCounter + 1;id := idCounter; return self)
			 pre len nameSeq > 0
			 post len name > 0 and 
			 id = idCounter~ + 1 and
			 boughtProducts = {} and
			 soldProducts = {} and 
			 boughtGiftCards = {} and
			 RESULT = self;
	
	public pure getId: () ==> nat1
	getId() == 
		return id
		pre true
		post RESULT=id;

	/*
	Post:
	- Has one more product of the bought kind in purchase transactions than previously.
	*/
	public buyProduct: Product ==> ()
	buyProduct(product) ==
		(
		boughtProducts := boughtProducts union {product};
		)
		pre true
		post
			card boughtProducts = card boughtProducts~ + 1
			and product in set boughtProducts;
		
	/*
	Pre:
	Post:
	- Has one more product of the sold kind in sales transactions than previously.
	*/
	public sellProduct: Product ==> ()
	sellProduct(product) ==
		soldProducts := soldProducts union {product}
		pre true
		post
			card soldProducts = card soldProducts~ + 1
			and product in set soldProducts;
			
	public buyGiftCard: GiftCard ==> ()
	buyGiftCard(giftCard) ==
		boughtGiftCards := boughtGiftCards union {giftCard}
		pre true
		post card boughtGiftCards = card boughtGiftCards~ + 1 and
		giftCard in set boughtGiftCards;
		
	pure valuesFromGiftCards: set of GiftCard ==> seq of nat 
	valuesFromGiftCards(g) ==
	 	(dcl result: seq of nat := [];
		for all giftCard in set g do 
			(result := result ^ [giftCard.getValue()];);
		return result;)
		pre true
		post card g = len RESULT;
		
functions
	
		

traces
-- TODO Define Combinatorial Test Traces here
end Client