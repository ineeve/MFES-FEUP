class Client
types
	public NotEmptyString = seq1 of char;
values
instance variables
	static idCounter: nat := 0;
	id: nat;
	creditNotes: nat;
	name: NotEmptyString;
	ownedGiftCards: set of GiftCard;
	transactions: set of Transaction;
	inv creditNotes >= 0;
operations
	public Client(nameSeq: NotEmptyString) c: Client ==
			(creditNotes:=0;name:=nameSeq; ownedGiftCards:={};transactions:={};idCounter := idCounter + 1;id := idCounter; return self)
			 pre len nameSeq > 0
			 post creditNotes = 0 and len name > 0
			 		and ownedGiftCards = {} and transactions = {} and id = idCounter~ + 1;
	
	public getCreditNotes() res: nat == 
			return creditNotes
			pre true
			post res = creditNotes;
	
	public addCreditNote(x: nat) ==
			creditNotes := creditNotes + x
			pre x > 0
			post creditNotes = creditNotes~ + x and creditNotes > 0;
	
	/**
	Spend a credit note of value x
	The value of the credit note to send should be less or equal than the creditNotes amount
	*/		
	public spendCreditNote(x: nat) == 
			creditNotes := creditNotes - x
			pre x <= creditNotes and x > 0
			post creditNotes = creditNotes~ - x;
	
	/*
	Post:
	- Gifted client has one more gift card than previously.
	- Gifted client has one more gift card with the given value than prevously.
	*/
	public addGiftCard(value: nat1) ==
		is not yet specified
		pre true
		post
			card ownedGiftCards = card ownedGiftCards~ + 1
			and len [x | x in seq valuesFromGiftCards(ownedGiftCards) & x = value]
				= len [x | x in seq valuesFromGiftCards(ownedGiftCards~) & x = value] + 1;
	
	/**
	Remove a giftCard from this client.
	Post condition ensures that only the given giftCard is removed.
	*/			
	public removeGiftCard(giftCard: GiftCard) == 
		is not yet specified
		pre giftCard in set ownedGiftCards
		post ownedGiftCards = ownedGiftCards~ \ {giftCard};
			
	public buyGiftCard(value: nat1, giftedClient: Client) ==
		giftedClient.addGiftCard(value)
		pre true
		post true;
		
	/*
	Post:
	- Has one more product of the bought kind in purchase transactions than previously.
	*/
	public buyProduct(product: Product, giftCards: set of GiftCard) ==
		is not yet specified
		pre true
		post
			card getBoughtProducts(transactions) = card getBoughtProducts(transactions~) + 1;
		
	/*
	Pre:
	Post:
	- Has one more product of the sold kind in sales transactions than previously.
	*/
	public sellProduct(product: Product) ==
		is not yet specified
		pre true
		post
			card getSoldProducts(transactions) = card getSoldProducts(transactions~) + 1;
			
	/*
	Pre:
	- Given gift card isn't nil.
	*/
	public pure ownsGiftCard(giftCard: GiftCard) b: bool ==
		(b := giftCard in set ownedGiftCards;
		return b)
		pre true
		post b = giftCard in set ownedGiftCards;
	
	/*
	Pre:
	- There's at least 1 gift card in the given set.
	*/
	public pure ownsGiftCards(giftCards: set of GiftCard) b: bool ==
		(for all x in set giftCards do b := b and ownsGiftCard(x);
		return b)
		pre card giftCards >= 1
		post forall x in set giftCards & b = b and ownsGiftCard(x);
		
pure valuesFromGiftCards(g: set of GiftCard) res: seq of nat ==
	 (dcl result: seq of nat := [];
		for all giftCard in set g do 
		(result := result ^ [giftCard.getValue()];);
		return result;)
		pre true
		post card g = len res;
		
pure getSoldProducts(tSet: set of Transaction) res: set of Product == 
	(dcl result: set of Product := {};
	for all t in set tSet do
	(if isofclass(Sale, t)
	then result := result union t.getProducts();
	);
	return result;)
	pre true
	post true;

pure getBoughtProducts(tSet: set of Transaction) res: set of Product == 
	(dcl result: set of Product := {};
	for all t in set tSet do
	(if isofclass(Purchase, t)
	then result := result union t.getProducts();
	);
	return result;)
	pre true
	post true
functions
	
		

traces
-- TODO Define Combinatorial Test Traces here
end Client